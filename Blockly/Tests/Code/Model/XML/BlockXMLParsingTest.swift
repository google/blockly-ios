/*
* Copyright 2016 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License")
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

@testable import Blockly
import XCTest
import SWXMLHash

class BlockXMLParsingTest: XCTestCase {

  // MARK: - Tests

  func testLoadBlockTreeFromXML() {
    let factory = try! BlockFactory(jsonPath: "xml_parsing_test",
      bundle: NSBundle(forClass: self.dynamicType))

    // TODO:(#334) Test blocks with negative workspace coordinates.
    if let blockTree = parseBlockFromXML(BlockTestStrings.SIMPLE_BLOCK, factory) {
      XCTAssertEqual(WorkspacePointMake(37, 13), blockTree.rootBlock.position)
    } else {
      XCTFail("Block tree was not parsed")
    }

    // All blocks need a type. Ids can be generated by the BlockFactory.
    XCTAssertNil(parseBlockFromXML(BlockTestStrings.NO_BLOCK_TYPE, factory))
    XCTAssertNotNil(parseBlockFromXML(BlockTestStrings.NO_BLOCK_ID, factory))

    // Only top level blocks need a position.
    XCTAssertNotNil(parseBlockFromXML(BlockTestStrings.NO_BLOCK_POSITION, factory))

    // Values.
    XCTAssertNotNil(
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_GOOD), factory))
    // Value: no output connection on child
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_NO_OUTPUT), factory))
    // value: null child block
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_NO_CHILD), factory))
    // Value: no input with that name
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_BAD_NAME), factory))
    // Value: multiple values for the same input
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_REPEATED), factory))

    // Comment: with text
    XCTAssertNotNil(
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.COMMENT_GOOD), factory))
    // Comment: empty string
    XCTAssertNotNil(
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.COMMENT_NO_TEXT), factory))

    // Fields
    if let blockTree = parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_HAS_NAME), factory)
    {
      XCTAssertEqual("item", blockTree.rootBlock.firstFieldWithName("text_input")?.text)
    } else {
      XCTFail("Block tree was not parsed")
    }
    // A missing or unknown field name isn't an error, it's just ignored.
    XCTAssertNotNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_MISSING_NAME), factory))
    XCTAssertNotNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_UNKNOWN_NAME), factory))
    XCTAssertNotNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_MISSING_TEXT), factory))

    // Statement: null child block
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_NO_CHILD), factory))
    // Statement: no previous connection on child block
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_BAD_CHILD), factory))
    // Statement: no input with that name
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_BAD_NAME), factory))

    // Statement
    XCTAssertNotNil(
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_GOOD), factory))
  }

  // MARK: - Helper methods

  func parseBlockFromXML(xmlString: String, _ factory: BlockFactory) -> Block.BlockTree? {
    let xml = SWXMLHash.parse(xmlString)

    // SWXMLHash always creates a root element around xml string, so pick its first child to pass
    // into blockTreeFromXML(...).
    if let blockXML = xml.children.first {
      do {
        return try Block.blockTreeFromXML(blockXML, factory: factory)
      } catch {
      }
    }

    return nil
  }
}
