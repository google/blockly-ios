/*
* Copyright 2016 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License")
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

@testable import Blockly
import XCTest
import AEXML

class BlockXMLParsingTest: XCTestCase {

  // MARK: - Setup

  var factory: BlockFactory!

  override func setUp() {
    factory = try! BlockFactory(jsonPath: "xml_parsing_test",
      bundle: NSBundle(forClass: self.dynamicType))

    super.setUp()
  }

  // MARK: - Tests

  func testLoadSimpleBlocks() {
    if let rootBlock = parseBlockFromXML(BlockTestStrings.SIMPLE_BLOCK, factory)?.rootBlock {
      XCTAssertEqual(WorkspacePointMake(37, 13), rootBlock.position)
      XCTAssertEqual("3", rootBlock.uuid)
      XCTAssertEqual("simple_block", rootBlock.firstFieldWithName("text_input")?.text)
    } else {
      XCTFail("Block tree was not parsed")
    }

    // All blocks need a type. Ids can be generated by the BlockFactory.
    if let rootBlock = parseBlockFromXML(BlockTestStrings.NO_BLOCK_ID, factory)?.rootBlock {
      XCTAssertEqual(WorkspacePointMake(-135, -902), rootBlock.position)
      XCTAssertEqual("no_block_id", rootBlock.firstFieldWithName("text_input")?.text)
    } else {
      XCTFail("Block tree was not parsed")
    }
    XCTAssertNil(parseBlockFromXML(BlockTestStrings.NO_BLOCK_TYPE, factory))

    // Only top level blocks need a position.
    XCTAssertNotNil(parseBlockFromXML(BlockTestStrings.NO_BLOCK_POSITION, factory))
  }

  func testLoadBlocksWithValues() {
    // Values.
    if let blockTree =
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_GOOD), factory)
    {
      XCTAssertEqual(2, blockTree.allBlocks.count)
      let block = blockTree.rootBlock.firstInputWithName("value_input")?.connectedBlock
      XCTAssertEqual("6", block?.uuid)
    } else {
      XCTFail("Block tree was not parsed")
    }
    // Value: no output connection on child
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_NO_OUTPUT), factory))
    // value: null child block
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_NO_CHILD), factory))
    // Value: no input with that name
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_BAD_NAME), factory))
    // Value: multiple values for the same input
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.VALUE_REPEATED), factory))
  }

  func testLoadBlocksWithComments() {
    // Comment: with text
    if let blockTree =
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.COMMENT_GOOD), factory)
    {
      XCTAssertEqual("Calm", blockTree.rootBlock.comment)
    } else {
      XCTFail("Block tree was not parsed")
    }

    // Comment: empty string
    if let blockTree =
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.COMMENT_NO_TEXT), factory)
    {
      XCTAssertEqual("", blockTree.rootBlock.comment)
    } else {
      XCTFail("Block tree was not parsed")
    }
  }

  func testLoadBlocksWithFields() {
    // Fields
    if let blockTree = parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_HAS_NAME), factory)
    {
      XCTAssertEqual("field_has_name", blockTree.rootBlock.firstFieldWithName("text_input")?.text)
    } else {
      XCTFail("Block tree was not parsed")
    }
    // A missing or unknown field name isn't an error, it's just ignored.
    XCTAssertNotNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_MISSING_NAME), factory))
    XCTAssertNotNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_UNKNOWN_NAME), factory))
    XCTAssertNotNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.FIELD_MISSING_TEXT), factory))
  }

  func testLoadBlocksWithStatements() {
    // Statement
    if let blockTree =
      parseBlockFromXML(BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_GOOD), factory)
    {
      XCTAssertEqual(2, blockTree.allBlocks.count)
      let block = blockTree.rootBlock.firstInputWithName("NAME")?.connectedBlock
      XCTAssertEqual("11", block?.uuid)
    } else {
      XCTFail("Block tree was not parsed")
    }

    // Statement: null child block
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_NO_CHILD), factory))
    // Statement: no previous connection on child block
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_BAD_CHILD), factory))
    // Statement: no input with that name
    XCTAssertNil(parseBlockFromXML(
      BlockTestStrings.assembleBlock(BlockTestStrings.STATEMENT_BAD_NAME), factory))
  }

  // MARK: - Helper methods

  func parseBlockFromXML(xmlString: String, _ factory: BlockFactory) -> Block.BlockTree? {
    do {
      let xmlDoc = try AEXMLDocument(string: xmlString)
      return try Block.blockTreeFromXML(xmlDoc.root, factory: factory)
    } catch {
    }

    return nil
  }
}
